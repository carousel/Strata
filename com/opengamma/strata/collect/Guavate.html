<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.4) on Wed Dec 04 13:52:32 CET 2019 -->
<title>Guavate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2019-12-04">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Guavate";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.opengamma.strata.collect</a></div>
<h2 title="Class Guavate" class="title">Class Guavate</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.opengamma.strata.collect.Guavate</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public final class <span class="typeNameLabel">Guavate</span>
extends java.lang.Object</pre>
<div class="block">Utilities that help bridge the gap between Java 8 and Google Guava.
 <p>
 Guava has the <code>FluentIterable</code> concept which is similar to streams.
 In many ways, fluent iterable is nicer, because it directly binds to the
 immutable collection classes. However, on balance it seems wise to use
 the stream API rather than <code>FluentIterable</code> in Java 8.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static java.lang.Class&lt;?&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#callerClass(int)">callerClass</a></span>&#8203;(int&nbsp;callStackDepth)</code></th>
<td class="colLast">
<div class="block">Finds the caller class.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;R extends T&gt;<br>java.util.function.Function&lt;T,&#8203;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#casting(java.lang.Class)">casting</a></span>&#8203;(java.lang.Class&lt;R&gt;&nbsp;cls)</code></th>
<td class="colLast">
<div class="block">Function used in a stream to cast instances to a particular type without filtering.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletableFuture&lt;java.util.List&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combineFuturesAsList(java.util.List)">combineFuturesAsList</a></span>&#8203;(java.util.List&lt;? extends java.util.concurrent.CompletableFuture&lt;? extends T&gt;&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">Converts a list of futures to a single future, combining the values into a list.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static &lt;K,&#8203;V,&#8203;F extends java.util.concurrent.CompletableFuture&lt;? extends V&gt;&gt;<br>java.util.concurrent.CompletableFuture&lt;java.util.Map&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combineFuturesAsMap(java.util.Map)">combineFuturesAsMap</a></span>&#8203;(java.util.Map&lt;? extends K,&#8203;? extends F&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">Converts a map of futures to a single future.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static &lt;K,&#8203;V&gt;<br>com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combineMaps(java.util.Map,java.util.Map)">combineMaps</a></span>&#8203;(java.util.Map&lt;? extends K,&#8203;? extends V&gt;&nbsp;first,
           java.util.Map&lt;? extends K,&#8203;? extends V&gt;&nbsp;second)</code></th>
<td class="colLast">
<div class="block">Combines two distinct maps into a single map.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static &lt;K,&#8203;V&gt;<br>com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#combineMaps(java.util.Map,java.util.Map,java.util.function.BiFunction)">combineMaps</a></span>&#8203;(java.util.Map&lt;? extends K,&#8203;? extends V&gt;&nbsp;first,
           java.util.Map&lt;? extends K,&#8203;? extends V&gt;&nbsp;second,
           java.util.function.BiFunction&lt;? super V,&#8203;? super V,&#8203;? extends V&gt;&nbsp;mergeFn)</code></th>
<td class="colLast">
<div class="block">Combines two maps into a single map.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;com.google.common.collect.ImmutableList&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concatToList(java.lang.Iterable...)">concatToList</a></span>&#8203;(java.lang.Iterable&lt;? extends T&gt;...&nbsp;iterables)</code></th>
<td class="colLast">
<div class="block">Concatenates a number of iterables into a single list.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;com.google.common.collect.ImmutableSet&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concatToSet(java.lang.Iterable...)">concatToSet</a></span>&#8203;(java.lang.Iterable&lt;? extends T&gt;...&nbsp;iterables)</code></th>
<td class="colLast">
<div class="block">Concatenates a number of iterables into a single set.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.function.BinaryOperator&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ensureOnlyOne()">ensureOnlyOne</a></span>()</code></th>
<td class="colLast">
<div class="block">Reducer used in a stream to ensure there is no more than one matching element.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static &lt;K,&#8203;V&gt;<br>java.util.stream.Collector&lt;java.util.Map.Entry&lt;? extends K,&#8203;? extends V&gt;,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#entriesToImmutableMap()">entriesToImmutableMap</a></span>()</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable map
 from a stream containing map entries.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static &lt;K,&#8203;V&gt;<br>java.util.stream.Collector&lt;java.util.Map.Entry&lt;? extends K,&#8203;? extends V&gt;,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#entriesToImmutableMap(java.util.function.BiFunction)">entriesToImmutableMap</a></span>&#8203;(java.util.function.BiFunction&lt;? super V,&#8203;? super V,&#8203;? extends V&gt;&nbsp;mergeFn)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable map
 from a stream containing map entries which could have duplicate keys.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static &lt;K,&#8203;V&gt;<br>java.util.Map.Entry&lt;K,&#8203;V&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#entry(K,V)">entry</a></span>&#8203;(K&nbsp;key,
     V&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Creates a single <code>Map.Entry</code>.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;R extends T&gt;<br>java.util.function.Function&lt;T,&#8203;java.util.stream.Stream&lt;R&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#filtering(java.lang.Class)">filtering</a></span>&#8203;(java.lang.Class&lt;R&gt;&nbsp;cls)</code></th>
<td class="colLast">
<div class="block">Function used in a stream to filter instances to a particular type.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.function.Function&lt;java.util.Optional&lt;T&gt;,&#8203;java.util.stream.Stream&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#filteringOptional()">filteringOptional</a></span>()</code></th>
<td class="colLast">
<div class="block">Function used in a stream to filter optionals.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Optional&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#first(java.lang.Iterable)">first</a></span>&#8203;(java.lang.Iterable&lt;T&gt;&nbsp;iterable)</code></th>
<td class="colLast">
<div class="block">Gets the first value from the iterable, returning empty if the iterable is empty.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Optional&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#firstNonEmpty(java.util.function.Supplier...)">firstNonEmpty</a></span>&#8203;(java.util.function.Supplier&lt;java.util.Optional&lt;? extends T&gt;&gt;...&nbsp;suppliers)</code></th>
<td class="colLast">
<div class="block">Uses a number of suppliers to create a single optional result.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Optional&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#firstNonEmpty(java.util.Optional...)">firstNonEmpty</a></span>&#8203;(java.util.Optional&lt;? extends T&gt;...&nbsp;optionals)</code></th>
<td class="colLast">
<div class="block">Chooses the first optional that is not empty.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.lang.Iterable&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#in(java.util.stream.Stream)">in</a></span>&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream)</code></th>
<td class="colLast">
<div class="block">Converts a stream to an iterable for use in the for-each statement.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.lang.Iterable&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#inOptional(java.util.Optional)">inOptional</a></span>&#8203;(java.util.Optional&lt;T&gt;&nbsp;optional)</code></th>
<td class="colLast">
<div class="block">Converts an optional to an iterable for use in the for-each statement.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static com.google.common.util.concurrent.ThreadFactoryBuilder</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#namedThreadFactory()">namedThreadFactory</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a ThreadFactoryBuilder which names new threads with the name of the calling class plus a unique integer.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static com.google.common.util.concurrent.ThreadFactoryBuilder</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#namedThreadFactory(java.lang.String)">namedThreadFactory</a></span>&#8203;(java.lang.String&nbsp;threadNamePrefix)</code></th>
<td class="colLast">
<div class="block">Creates a ThreadFactoryBuilder which names new threads with the given name prefix plus a unique integer.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;java.util.function.Predicate&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#not(java.util.function.Predicate)">not</a></span>&#8203;(java.util.function.Predicate&lt;R&gt;&nbsp;predicate)</code></th>
<td class="colLast">
<div class="block">Returns a predicate that negates the original.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static &lt;K,&#8203;V&gt;<br>java.util.stream.Collector&lt;<a href="tuple/Pair.html" title="class in com.opengamma.strata.collect.tuple">Pair</a>&lt;? extends K,&#8203;? extends V&gt;,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pairsToImmutableMap()">pairsToImmutableMap</a></span>()</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable map
 from a stream containing pairs.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.concurrent.CompletableFuture&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#poll(java.util.concurrent.ScheduledExecutorService,java.time.Duration,java.time.Duration,java.util.function.Supplier)">poll</a></span>&#8203;(java.util.concurrent.ScheduledExecutorService&nbsp;executorService,
    java.time.Duration&nbsp;initialDelay,
    java.time.Duration&nbsp;frequency,
    java.util.function.Supplier&lt;T&gt;&nbsp;pollingTask)</code></th>
<td class="colLast">
<div class="block">Polls on a regular frequency until a result is found.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableList&lt;com.google.common.collect.ImmutableList&lt;T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#splittingBySize(int)">splittingBySize</a></span>&#8203;(int&nbsp;size)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable list of
 immutable lists of size equal to or less than size.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#stream(java.lang.Iterable)">stream</a></span>&#8203;(java.lang.Iterable&lt;T&gt;&nbsp;iterable)</code></th>
<td class="colLast">
<div class="block">Converts an iterable to a serial stream.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#stream(java.util.Optional)">stream</a></span>&#8203;(java.util.Optional&lt;T&gt;&nbsp;optional)</code></th>
<td class="colLast">
<div class="block">Converts an optional to a stream with zero or one elements.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;S extends java.util.concurrent.CompletableFuture&lt;? extends T&gt;&gt;<br>java.util.stream.Collector&lt;S,&#8203;?,&#8203;java.util.concurrent.CompletableFuture&lt;java.util.List&lt;T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCombinedFuture()">toCombinedFuture</a></span>()</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to convert a list of futures to a single future,
 combining the values into a list.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static &lt;K,&#8203;V,&#8203;F extends java.util.concurrent.CompletableFuture&lt;? extends V&gt;&gt;<br>java.util.stream.Collector&lt;java.util.Map.Entry&lt;? extends K,&#8203;? extends F&gt;,&#8203;?,&#8203;java.util.concurrent.CompletableFuture&lt;java.util.Map&lt;K,&#8203;V&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCombinedFutureMap()">toCombinedFutureMap</a></span>()</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to convert a map of futures to a single future,
 combining the values into a map.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableList.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableList&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableList()">toImmutableList</a></span>()</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable list.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;K&gt;<br>java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableListMultimap&lt;K,&#8203;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableListMultimap(java.util.function.Function)">toImmutableListMultimap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable multimap.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;K,&#8203;V&gt;<br>java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableListMultimap&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableListMultimap(java.util.function.Function,java.util.function.Function)">toImmutableListMultimap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                       java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable multimap.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;K&gt;<br>java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableMap(java.util.function.Function)">toImmutableMap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable map.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;K,&#8203;V&gt;<br>java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableMap(java.util.function.Function,java.util.function.Function)">toImmutableMap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
              java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable map.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;K,&#8203;V&gt;<br>java.util.stream.Collector&lt;T,&#8203;java.util.Map&lt;K,&#8203;V&gt;,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableMap(java.util.function.Function,java.util.function.Function,java.util.function.BiFunction)">toImmutableMap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
              java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor,
              java.util.function.BiFunction&lt;? super V,&#8203;? super V,&#8203;? extends V&gt;&nbsp;mergeFn)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable map.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableMultiset.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableMultiset&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableMultiset()">toImmutableMultiset</a></span>()</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable multiset.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableSet.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableSet&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableSet()">toImmutableSet</a></span>()</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable set.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;K&gt;<br>java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSetMultimap&lt;K,&#8203;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableSetMultimap(java.util.function.Function)">toImmutableSetMultimap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable multimap.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;K,&#8203;V&gt;<br>java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSetMultimap&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableSetMultimap(java.util.function.Function,java.util.function.Function)">toImmutableSetMultimap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                      java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable multimap.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;K extends java.lang.Comparable&lt;?&gt;&gt;<br>java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSortedMap&lt;K,&#8203;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableSortedMap(java.util.function.Function)">toImmutableSortedMap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable sorted map.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;K extends java.lang.Comparable&lt;?&gt;,&#8203;V&gt;<br>java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSortedMap&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableSortedMap(java.util.function.Function,java.util.function.Function)">toImmutableSortedMap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                    java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable sorted map.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;K extends java.lang.Comparable&lt;?&gt;,&#8203;V&gt;<br>java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSortedMap&lt;K,&#8203;V&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableSortedMap(java.util.function.Function,java.util.function.Function,java.util.function.BiFunction)">toImmutableSortedMap</a></span>&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                    java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor,
                    java.util.function.BiFunction&lt;? super V,&#8203;? super V,&#8203;? extends V&gt;&nbsp;mergeFn)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable sorted map.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static &lt;T extends java.lang.Comparable&lt;?&gt;&gt;<br>java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableSortedSet.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableSortedSet&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableSortedSet()">toImmutableSortedSet</a></span>()</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable sorted set.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableSortedSet.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableSortedSet&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toImmutableSortedSet(java.util.Comparator)">toImmutableSortedSet</a></span>&#8203;(java.util.Comparator&lt;? super T&gt;&nbsp;comparator)</code></th>
<td class="colLast">
<div class="block">Collector used at the end of a stream to build an immutable sorted set.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static &lt;A,&#8203;B&gt;<br>java.util.stream.Stream&lt;<a href="tuple/Pair.html" title="class in com.opengamma.strata.collect.tuple">Pair</a>&lt;A,&#8203;B&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zip(java.util.stream.Stream,java.util.stream.Stream)">zip</a></span>&#8203;(java.util.stream.Stream&lt;A&gt;&nbsp;stream1,
   java.util.stream.Stream&lt;B&gt;&nbsp;stream2)</code></th>
<td class="colLast">
<div class="block">Creates a stream that combines two other streams, continuing until either stream ends.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;<a href="tuple/ObjIntPair.html" title="class in com.opengamma.strata.collect.tuple">ObjIntPair</a>&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zipWithIndex(java.util.stream.Stream)">zipWithIndex</a></span>&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream)</code></th>
<td class="colLast">
<div class="block">Creates a stream that wraps a stream with the index.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="concatToList(java.lang.Iterable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatToList</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;com.google.common.collect.ImmutableList&lt;T&gt;&nbsp;concatToList&#8203;(java.lang.Iterable&lt;? extends T&gt;...&nbsp;iterables)</pre>
<div class="block">Concatenates a number of iterables into a single list.
 <p>
 This is harder than it should be, a method <code>Stream.of(Iterable)</code>
 would have been appropriate, but cannot be added now.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the iterable</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>iterables</code> - the iterables to combine</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the list that combines the inputs</dd>
</dl>
</li>
</ul>
<a id="concatToSet(java.lang.Iterable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatToSet</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;com.google.common.collect.ImmutableSet&lt;T&gt;&nbsp;concatToSet&#8203;(java.lang.Iterable&lt;? extends T&gt;...&nbsp;iterables)</pre>
<div class="block">Concatenates a number of iterables into a single set.
 <p>
 This is harder than it should be, a method <code>Stream.of(Iterable)</code>
 would have been appropriate, but cannot be added now.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the iterable</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>iterables</code> - the iterables to combine</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the set that combines the inputs</dd>
</dl>
</li>
</ul>
<a id="combineMaps(java.util.Map,java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineMaps</h4>
<pre class="methodSignature">public static&nbsp;&lt;K,&#8203;V&gt;&nbsp;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&nbsp;combineMaps&#8203;(java.util.Map&lt;? extends K,&#8203;? extends V&gt;&nbsp;first,
                                                                                        java.util.Map&lt;? extends K,&#8203;? extends V&gt;&nbsp;second)</pre>
<div class="block">Combines two distinct maps into a single map.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - the type of the keys</dd>
<dd><code>V</code> - the type of the values</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>first</code> - the first map</dd>
<dd><code>second</code> - the second map</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a combined map</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the same key is encountered in both maps</dd>
</dl>
</li>
</ul>
<a id="combineMaps(java.util.Map,java.util.Map,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineMaps</h4>
<pre class="methodSignature">public static&nbsp;&lt;K,&#8203;V&gt;&nbsp;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&nbsp;combineMaps&#8203;(java.util.Map&lt;? extends K,&#8203;? extends V&gt;&nbsp;first,
                                                                                        java.util.Map&lt;? extends K,&#8203;? extends V&gt;&nbsp;second,
                                                                                        java.util.function.BiFunction&lt;? super V,&#8203;? super V,&#8203;? extends V&gt;&nbsp;mergeFn)</pre>
<div class="block">Combines two maps into a single map.
 <p>
 If the maps have shared keys then the merge function is used on the two values
 and the result is placed in the resulting map.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - the type of the keys</dd>
<dd><code>V</code> - the type of the values</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>first</code> - the first map</dd>
<dd><code>second</code> - the second map</dd>
<dd><code>mergeFn</code> - the function used to merge values</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a combined map</dd>
</dl>
</li>
</ul>
<a id="firstNonEmpty(java.util.function.Supplier...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>firstNonEmpty</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;java.util.Optional&lt;T&gt;&nbsp;firstNonEmpty&#8203;(java.util.function.Supplier&lt;java.util.Optional&lt;? extends T&gt;&gt;...&nbsp;suppliers)</pre>
<div class="block">Uses a number of suppliers to create a single optional result.
 <p>
 This invokes each supplier in turn until a non empty optional is returned.
 As such, not all suppliers are necessarily invoked.
 <p>
 The Java 8 <code>Optional</code> class does not have an <code>or</code> method,
 so this provides an alternative.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the optional</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>suppliers</code> - the suppliers to combine</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first non empty optional</dd>
</dl>
</li>
</ul>
<a id="firstNonEmpty(java.util.Optional...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>firstNonEmpty</h4>
<pre class="methodSignature">@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;java.util.Optional&lt;T&gt;&nbsp;firstNonEmpty&#8203;(java.util.Optional&lt;? extends T&gt;...&nbsp;optionals)</pre>
<div class="block">Chooses the first optional that is not empty.
 <p>
 The Java 8 <code>Optional</code> class does not have an <code>or</code> method,
 so this provides an alternative.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the optional</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>optionals</code> - the optionals to combine</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first non empty optional</dd>
</dl>
</li>
</ul>
<a id="first(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>first</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.Optional&lt;T&gt;&nbsp;first&#8203;(java.lang.Iterable&lt;T&gt;&nbsp;iterable)</pre>
<div class="block">Gets the first value from the iterable, returning empty if the iterable is empty.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the optional</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>iterable</code> - the iterable to query</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first value, empty if empty</dd>
</dl>
</li>
</ul>
<a id="entry(java.lang.Object,java.lang.Object)">
<!--   -->
</a><a id="entry(K,V)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>entry</h4>
<pre class="methodSignature">public static&nbsp;&lt;K,&#8203;V&gt;&nbsp;java.util.Map.Entry&lt;K,&#8203;V&gt;&nbsp;entry&#8203;(K&nbsp;key,
                                                               V&nbsp;value)</pre>
<div class="block">Creates a single <code>Map.Entry</code>.
 <p>
 The entry is immutable.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - the type of the key</dd>
<dd><code>V</code> - the type of the value</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - the key</dd>
<dd><code>value</code> - the value</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the map entry</dd>
</dl>
</li>
</ul>
<a id="stream(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stream</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;&nbsp;stream&#8203;(java.lang.Iterable&lt;T&gt;&nbsp;iterable)</pre>
<div class="block">Converts an iterable to a serial stream.
 <p>
 This is harder than it should be, a method <code>Stream.of(Iterable)</code>
 would have been appropriate, but cannot be added now.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the iterable</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>iterable</code> - the iterable to convert</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a stream of the elements in the iterable</dd>
</dl>
</li>
</ul>
<a id="stream(java.util.Optional)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stream</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;&nbsp;stream&#8203;(java.util.Optional&lt;T&gt;&nbsp;optional)</pre>
<div class="block">Converts an optional to a stream with zero or one elements.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of optional element</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>optional</code> - the optional</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a stream containing a single value if the optional has a value, else a stream with no values.</dd>
</dl>
</li>
</ul>
<a id="in(java.util.stream.Stream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>in</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.lang.Iterable&lt;T&gt;&nbsp;in&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream)</pre>
<div class="block">Converts a stream to an iterable for use in the for-each statement.
 <p>
 For some use cases this approach is nicer than <code>Stream.forEach(Consumer)</code>.
 Notably code that mutates a local variable or has to handle checked exceptions will benefit.
 <p>
 <pre>
  for (Item item : in(stream)) {
    // lazily use each item in the stream
  }
 </pre>
 <p>
 NOTE: The result of this method can only be iterated once, which does not
 meet the expected specification of <code>Iterable</code>.
 Use in the for-each statement is safe as it will only be called once.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of stream element</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stream</code> - the stream</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an iterable representation of the stream that can only be invoked once</dd>
</dl>
</li>
</ul>
<a id="inOptional(java.util.Optional)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inOptional</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.lang.Iterable&lt;T&gt;&nbsp;inOptional&#8203;(java.util.Optional&lt;T&gt;&nbsp;optional)</pre>
<div class="block">Converts an optional to an iterable for use in the for-each statement.
 <p>
 For some use cases this approach is nicer than <code>Optional.isPresent()</code>
 followed by <code>Optional.get()</code>.
 <p>
 <pre>
  for (Item item : inOptional(optional)) {
    // use the optional value, code not called if the optional is empty
  }
 </pre>
 <p>
 NOTE: This method is intended only for use with the for-each statement.
 It does in fact return a general purpose <code>Iterable</code>, but the method name
 is focussed on the for-each use case.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of optional element</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>optional</code> - the optional</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an iterable representation of the optional</dd>
</dl>
</li>
</ul>
<a id="zipWithIndex(java.util.stream.Stream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWithIndex</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;<a href="tuple/ObjIntPair.html" title="class in com.opengamma.strata.collect.tuple">ObjIntPair</a>&lt;T&gt;&gt;&nbsp;zipWithIndex&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream)</pre>
<div class="block">Creates a stream that wraps a stream with the index.
 <p>
 Each input object is decorated with an <a href="tuple/ObjIntPair.html" title="class in com.opengamma.strata.collect.tuple"><code>ObjIntPair</code></a>.
 The <code>int</code> is the index of the element in the stream.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stream</code> - the stream to index</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a stream of pairs, containing the element and index</dd>
</dl>
</li>
</ul>
<a id="zip(java.util.stream.Stream,java.util.stream.Stream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre class="methodSignature">public static&nbsp;&lt;A,&#8203;B&gt;&nbsp;java.util.stream.Stream&lt;<a href="tuple/Pair.html" title="class in com.opengamma.strata.collect.tuple">Pair</a>&lt;A,&#8203;B&gt;&gt;&nbsp;zip&#8203;(java.util.stream.Stream&lt;A&gt;&nbsp;stream1,
                                                                       java.util.stream.Stream&lt;B&gt;&nbsp;stream2)</pre>
<div class="block">Creates a stream that combines two other streams, continuing until either stream ends.
 <p>
 Each pair of input objects is combined into a <a href="tuple/Pair.html" title="class in com.opengamma.strata.collect.tuple"><code>Pair</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>A</code> - the type of the first stream</dd>
<dd><code>B</code> - the type of the second stream</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stream1</code> - the first stream</dd>
<dd><code>stream2</code> - the first stream</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a stream of pairs, one from each stream</dd>
</dl>
</li>
</ul>
<a id="not(java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>not</h4>
<pre class="methodSignature">public static&nbsp;&lt;R&gt;&nbsp;java.util.function.Predicate&lt;R&gt;&nbsp;not&#8203;(java.util.function.Predicate&lt;R&gt;&nbsp;predicate)</pre>
<div class="block">Returns a predicate that negates the original.
 <p>
 The JDK provides <code>Predicate.negate()</code> however this requires a predicate.
 Sometimes, it can be useful to have a static method to achieve this.
 <pre>
  stream.filter(not(String::isEmpty))
 </pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>R</code> - the type of the object the predicate works on</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - the predicate to negate</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the negated predicate</dd>
</dl>
</li>
</ul>
<a id="ensureOnlyOne()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ensureOnlyOne</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.function.BinaryOperator&lt;T&gt;&nbsp;ensureOnlyOne()</pre>
<div class="block">Reducer used in a stream to ensure there is no more than one matching element.
 <p>
 This method returns an operator that can be used with <code>Stream.reduce(BinaryOperator)</code>
 that returns either zero or one elements from the stream. Unlike <code>Stream.findFirst()</code>
 or <code>Stream.findAny()</code>, this approach ensures an exception is thrown if there
 is more than one element in the stream.
 <p>
 This would be used as follows (with a static import):
 <pre>
   stream.filter(...).reduce(ensureOnlyOne()).get();
 </pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the stream</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the operator</dd>
</dl>
</li>
</ul>
<a id="casting(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>casting</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;R extends T&gt;&nbsp;java.util.function.Function&lt;T,&#8203;R&gt;&nbsp;casting&#8203;(java.lang.Class&lt;R&gt;&nbsp;cls)</pre>
<div class="block">Function used in a stream to cast instances to a particular type without filtering.
 <p>
 This method returns a function that can be used with <code>Stream.map(Function)</code>
 to cast elements in a stream to a particular type, throwing an exception if any
 element is not of the specified type.
 <p>
 This would be used as follows (with a static import):
 <pre>
   stream.map(casting(Foo.class));
 </pre>
 <p>
 This replaces code of the form:
 <pre>
   stream.map(Foo.class::cast);
 </pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the input stream</dd>
<dd><code>R</code> - the type of element in the output stream</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cls</code> - the type of element in the output stream</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the function</dd>
</dl>
</li>
</ul>
<a id="filtering(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filtering</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;R extends T&gt;&nbsp;java.util.function.Function&lt;T,&#8203;java.util.stream.Stream&lt;R&gt;&gt;&nbsp;filtering&#8203;(java.lang.Class&lt;R&gt;&nbsp;cls)</pre>
<div class="block">Function used in a stream to filter instances to a particular type.
 <p>
 This method returns a function that can be used with <code>Stream.flatMap(Function)</code>
 to filter elements in a stream to a particular type.
 <p>
 This would be used as follows (with a static import):
 <pre>
   stream.flatMap(filtering(Foo.class));
 </pre>
 <p>
 This replaces code of the form:
 <pre>
   stream.filter(Foo.class::isInstance).map(Foo.class::cast);
 </pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the input stream</dd>
<dd><code>R</code> - the type of element in the output stream</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cls</code> - the type of element in the output stream</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the function</dd>
</dl>
</li>
</ul>
<a id="filteringOptional()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filteringOptional</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.function.Function&lt;java.util.Optional&lt;T&gt;,&#8203;java.util.stream.Stream&lt;T&gt;&gt;&nbsp;filteringOptional()</pre>
<div class="block">Function used in a stream to filter optionals.
 <p>
 This method returns a function that can be used with <code>Stream.flatMap(Function)</code>
 to filter optional elements in a stream.
 The resulting stream only contains the optional elements that are present.
 <p>
 This would be used as follows (with a static import):
 <pre>
   stream.flatMap(filteringOptional());
 </pre>
 <p>
 This replaces code of the form:
 <pre>
   stream.filter(Optional::isPresent).map(Optional::get);
 </pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the output stream</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the function</dd>
</dl>
</li>
</ul>
<a id="toImmutableList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableList</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableList.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableList&lt;T&gt;&gt;&nbsp;toImmutableList()</pre>
<div class="block">Collector used at the end of a stream to build an immutable list.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableList</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the list</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable list collector</dd>
</dl>
</li>
</ul>
<a id="splittingBySize(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>splittingBySize</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableList&lt;com.google.common.collect.ImmutableList&lt;T&gt;&gt;&gt;&nbsp;splittingBySize&#8203;(int&nbsp;size)</pre>
<div class="block">Collector used at the end of a stream to build an immutable list of
 immutable lists of size equal to or less than size.
 For example, the following list [a, b, c, d, e] with a partition
 size of 2 will give [[a, b], [c, d], [e]].
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableList</code> of <code>ImmutableList</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the list</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - the size of the partitions of the original list</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable list of lists collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableSet()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableSet</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableSet.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableSet&lt;T&gt;&gt;&nbsp;toImmutableSet()</pre>
<div class="block">Collector used at the end of a stream to build an immutable set.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableSet</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the set</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable set collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableSortedSet()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableSortedSet</h4>
<pre class="methodSignature">public static&nbsp;&lt;T extends java.lang.Comparable&lt;?&gt;&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableSortedSet.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableSortedSet&lt;T&gt;&gt;&nbsp;toImmutableSortedSet()</pre>
<div class="block">Collector used at the end of a stream to build an immutable sorted set.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableSet</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the sorted set</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable sorted set collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableSortedSet(java.util.Comparator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableSortedSet</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableSortedSet.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableSortedSet&lt;T&gt;&gt;&nbsp;toImmutableSortedSet&#8203;(java.util.Comparator&lt;? super T&gt;&nbsp;comparator)</pre>
<div class="block">Collector used at the end of a stream to build an immutable sorted set.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableSet</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the sorted set</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>comparator</code> - the comparator</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable sorted set collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableMultiset()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableMultiset</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;com.google.common.collect.ImmutableMultiset.Builder&lt;T&gt;,&#8203;com.google.common.collect.ImmutableMultiset&lt;T&gt;&gt;&nbsp;toImmutableMultiset()</pre>
<div class="block">Collector used at the end of a stream to build an immutable multiset.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableMultiset</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of element in the multiset</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable multiset collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableMap(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;T&gt;&gt;&nbsp;toImmutableMap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor)</pre>
<div class="block">Collector used at the end of a stream to build an immutable map.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableMap</code>, retaining insertion order.
 <p>
 This returns a map by extracting a key from each element.
 The input stream must resolve to unique keys.
 The value associated with each key is the stream element.
 See <code>Collectors.toMap(Function, Function)</code> for more details.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result map</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable map collector</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the same key is generated twice</dd>
</dl>
</li>
</ul>
<a id="toImmutableMap(java.util.function.Function,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K,&#8203;V&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;&nbsp;toImmutableMap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                                                                                                                                               java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor)</pre>
<div class="block">Collector used at the end of a stream to build an immutable map.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableMap</code>, retaining insertion order.
 <p>
 This returns a map by converting each stream element to a key and value.
 The input stream must resolve to unique keys.
 See <code>Collectors.toMap(Function, Function)</code> for more details.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result map</dd>
<dd><code>V</code> - the type of the values in the result map</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dd><code>valueExtractor</code> - function to produce values from stream elements</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable map collector</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the same key is generated twice</dd>
</dl>
</li>
</ul>
<a id="toImmutableMap(java.util.function.Function,java.util.function.Function,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K,&#8203;V&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;java.util.Map&lt;K,&#8203;V&gt;,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;&nbsp;toImmutableMap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                                                                                                                                                                      java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor,
                                                                                                                                                                      java.util.function.BiFunction&lt;? super V,&#8203;? super V,&#8203;? extends V&gt;&nbsp;mergeFn)</pre>
<div class="block">Collector used at the end of a stream to build an immutable map.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableMap</code>, retaining insertion order.
 <p>
 This returns a map by converting each stream element to a key and value.
 If the same key is generated more than once the merge function is applied to the
 values and the return value of the function is used as the value in the map.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result map</dd>
<dd><code>V</code> - the type of the values in the result map</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dd><code>valueExtractor</code> - function to produce values from stream elements</dd>
<dd><code>mergeFn</code> - function to merge values with the same key</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable map collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableSortedMap(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableSortedMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K extends java.lang.Comparable&lt;?&gt;&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSortedMap&lt;K,&#8203;T&gt;&gt;&nbsp;toImmutableSortedMap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor)</pre>
<div class="block">Collector used at the end of a stream to build an immutable sorted map.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableSortedMap</code>.
 <p>
 This returns a map by extracting a key from each element.
 The input stream must resolve to unique keys.
 The value associated with each key is the stream element.
 See <code>Collectors.toMap(Function, Function)</code> for more details.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result map</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable sorted map collector</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the same key is generated twice</dd>
</dl>
</li>
</ul>
<a id="toImmutableSortedMap(java.util.function.Function,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableSortedMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K extends java.lang.Comparable&lt;?&gt;,&#8203;V&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSortedMap&lt;K,&#8203;V&gt;&gt;&nbsp;toImmutableSortedMap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                                                                                                                                                                                           java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor)</pre>
<div class="block">Collector used at the end of a stream to build an immutable sorted map.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableSortedMap</code>.
 <p>
 This returns a map by converting each stream element to a key and value.
 The input stream must resolve to unique keys.
 See <code>Collectors.toMap(Function, Function)</code> for more details.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result map</dd>
<dd><code>V</code> - the type of the values in the result map</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dd><code>valueExtractor</code> - function to produce values from stream elements</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable sorted map collector</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the same key is generated twice</dd>
</dl>
</li>
</ul>
<a id="toImmutableSortedMap(java.util.function.Function,java.util.function.Function,java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableSortedMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K extends java.lang.Comparable&lt;?&gt;,&#8203;V&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSortedMap&lt;K,&#8203;V&gt;&gt;&nbsp;toImmutableSortedMap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                                                                                                                                                                                           java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor,
                                                                                                                                                                                           java.util.function.BiFunction&lt;? super V,&#8203;? super V,&#8203;? extends V&gt;&nbsp;mergeFn)</pre>
<div class="block">Collector used at the end of a stream to build an immutable sorted map.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableSortedMap</code>.
 <p>
 This returns a map by converting each stream element to a key and value.
 See <code>Collectors.toMap(Function, Function)</code> for more details.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result map</dd>
<dd><code>V</code> - the type of the values in the result map</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dd><code>valueExtractor</code> - function to produce values from stream elements</dd>
<dd><code>mergeFn</code> - function to merge values with the same key</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable sorted map collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableListMultimap(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableListMultimap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableListMultimap&lt;K,&#8203;T&gt;&gt;&nbsp;toImmutableListMultimap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor)</pre>
<div class="block">Collector used at the end of a stream to build an immutable multimap.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableListMultimap</code>.
 <p>
 This returns a multimap by extracting a key from each element.
 The value associated with each key is the stream element.
 Stream elements may be converted to the same key, with the values forming a multimap list.
 See <code>Collectors.groupingBy(Function)</code> for more details.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result multimap</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable multimap collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableListMultimap(java.util.function.Function,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableListMultimap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K,&#8203;V&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableListMultimap&lt;K,&#8203;V&gt;&gt;&nbsp;toImmutableListMultimap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                                                                                                                                                                 java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor)</pre>
<div class="block">Collector used at the end of a stream to build an immutable multimap.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableListMultimap</code>.
 <p>
 This returns a multimap by converting each stream element to a key and value.
 Stream elements may be converted to the same key, with the values forming a multimap list.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result multimap</dd>
<dd><code>V</code> - the type of the values in the result multimap</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dd><code>valueExtractor</code> - function to produce values from stream elements</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable multimap collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableSetMultimap(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableSetMultimap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSetMultimap&lt;K,&#8203;T&gt;&gt;&nbsp;toImmutableSetMultimap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor)</pre>
<div class="block">Collector used at the end of a stream to build an immutable multimap.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableSetMultimap</code>.
 <p>
 This returns a multimap by extracting a key from each element.
 The value associated with each key is the stream element.
 Stream elements may be converted to the same key, with the values forming a multimap set.
 See <code>Collectors.groupingBy(Function)</code> for more details.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result multimap</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable multimap collector</dd>
</dl>
</li>
</ul>
<a id="toImmutableSetMultimap(java.util.function.Function,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toImmutableSetMultimap</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;K,&#8203;V&gt;&nbsp;java.util.stream.Collector&lt;T,&#8203;?,&#8203;com.google.common.collect.ImmutableSetMultimap&lt;K,&#8203;V&gt;&gt;&nbsp;toImmutableSetMultimap&#8203;(java.util.function.Function&lt;? super T,&#8203;? extends K&gt;&nbsp;keyExtractor,
                                                                                                                                                               java.util.function.Function&lt;? super T,&#8203;? extends V&gt;&nbsp;valueExtractor)</pre>
<div class="block">Collector used at the end of a stream to build an immutable multimap.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableSetMultimap</code>.
 <p>
 This returns a multimap by converting each stream element to a key and value.
 Stream elements may be converted to the same key, with the values forming a multimap set.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the stream elements</dd>
<dd><code>K</code> - the type of the keys in the result multimap</dd>
<dd><code>V</code> - the type of the values in the result multimap</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyExtractor</code> - function to produce keys from stream elements</dd>
<dd><code>valueExtractor</code> - function to produce values from stream elements</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable multimap collector</dd>
</dl>
</li>
</ul>
<a id="entriesToImmutableMap()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>entriesToImmutableMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;K,&#8203;V&gt;&nbsp;java.util.stream.Collector&lt;java.util.Map.Entry&lt;? extends K,&#8203;? extends V&gt;,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;&nbsp;entriesToImmutableMap()</pre>
<div class="block">Collector used at the end of a stream to build an immutable map
 from a stream containing map entries. This is a common case if a map's
 <code>entrySet</code> has undergone a <code>filter</code> operation. For example:
 <pre>
   <code>
       Map&lt;String, Integer&gt; input = ImmutableMap.of("a", 1, "b", 2, "c", 3, "d", 4, "e", 5);
       ImmutableMap&lt;String, Integer&gt; output =
         input.entrySet()
           .stream()
           .filter(e -&gt; e.getValue() % 2 == 1)
           .collect(entriesToImmutableMap());

       // Produces map with "a" -&gt; 1, "c" -&gt; 3, "e" -&gt; 5
   </code>
 </pre>
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableMap</code>.
 <p>
 This returns a map by converting each <code>Map.Entry</code> to a key and value.
 The input stream must resolve to unique keys.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - the type of the keys in the result map</dd>
<dd><code>V</code> - the type of the values in the result map</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable map collector</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the same key is generated twice</dd>
</dl>
</li>
</ul>
<a id="entriesToImmutableMap(java.util.function.BiFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>entriesToImmutableMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;K,&#8203;V&gt;&nbsp;java.util.stream.Collector&lt;java.util.Map.Entry&lt;? extends K,&#8203;? extends V&gt;,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;&nbsp;entriesToImmutableMap&#8203;(java.util.function.BiFunction&lt;? super V,&#8203;? super V,&#8203;? extends V&gt;&nbsp;mergeFn)</pre>
<div class="block">Collector used at the end of a stream to build an immutable map
 from a stream containing map entries which could have duplicate keys.
 <p>
 This is a common case if a map's <code>entrySet</code> has undergone a <code>map</code> operation. For example:
 <pre>
   <code>
       Map&lt;Integer, String&gt; input = ImmutableMap.of(1, "a", 2, "b", 3, "c", 4, "d", 5, "e");
       ImmutableMap&lt;String, Integer&gt; output =
         input.entrySet()
           .stream()
           .map(e -&gt; Guavate.entry(e.getKey() % 2, e.getValue()))
           .collect(entriesToImmutableMap(String::concat));

       // Produces map with 0 -&gt; "bd", 1 -&gt; "ace"
   </code>
 </pre>
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableMap</code>.
 <p>
 This returns a map by converting each <code>Map.Entry</code> to a key and value.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - the type of the keys in the result map</dd>
<dd><code>V</code> - the type of the values in the result map</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mergeFn</code> - function to merge values with the same key</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable map collector</dd>
</dl>
</li>
</ul>
<a id="pairsToImmutableMap()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pairsToImmutableMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;K,&#8203;V&gt;&nbsp;java.util.stream.Collector&lt;<a href="tuple/Pair.html" title="class in com.opengamma.strata.collect.tuple">Pair</a>&lt;? extends K,&#8203;? extends V&gt;,&#8203;?,&#8203;com.google.common.collect.ImmutableMap&lt;K,&#8203;V&gt;&gt;&nbsp;pairsToImmutableMap()</pre>
<div class="block">Collector used at the end of a stream to build an immutable map
 from a stream containing pairs. This is a common case if a map's
 <code>entrySet</code> has undergone a <code>map</code> operation with the
 <code>Map.Entry</code> converted to a <code>Pair</code>. For example:
 <pre>
   <code>
       Map&lt;String, Integer&gt; input = ImmutableMap.of("a", 1, "b", 2, "c", 3, "d", 4);
       ImmutableMap&lt;String, Double&gt; output =
         input.entrySet()
           .stream()
           .map(e -&gt; Pair.of(e.getKey().toUpperCase(), Math.pow(e.getValue(), 2)))
           .collect(pairsToImmutableMap());

       // Produces map with "A" -&gt; 1.0, "B" -&gt; 4.0, "C" -&gt; 9.0, "D" -&gt; 16.0
   </code>
 </pre>
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing streams to be gathered into
 an <code>ImmutableMap</code>.
 <p>
 This returns a map by converting each stream element to a key and value.
 The input stream must resolve to unique keys.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - the type of the keys in the result map</dd>
<dd><code>V</code> - the type of the values in the result map</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the immutable map collector</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the same key is generated twice</dd>
</dl>
</li>
</ul>
<a id="combineFuturesAsList(java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineFuturesAsList</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletableFuture&lt;java.util.List&lt;T&gt;&gt;&nbsp;combineFuturesAsList&#8203;(java.util.List&lt;? extends java.util.concurrent.CompletableFuture&lt;? extends T&gt;&gt;&nbsp;futures)</pre>
<div class="block">Converts a list of futures to a single future, combining the values into a list.
 <p>
 The <code>CompletableFuture.allOf(CompletableFuture...)</code> method is useful
 but it returns <code>Void</code>. This method combines the futures but also
 returns the resulting value as a list.
 Effectively, this converts <code>List&lt;CompletableFuture&lt;T&gt;&gt;</code> to <code>CompletableFuture&lt;List&lt;T&gt;&gt;</code>.
 <p>
 If any input future completes exceptionally, the result will also complete exceptionally.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type of the values in the list</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - the futures to convert, may be empty</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a future that combines the input futures as a list</dd>
</dl>
</li>
</ul>
<a id="toCombinedFuture()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toCombinedFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;S extends java.util.concurrent.CompletableFuture&lt;? extends T&gt;&gt;&nbsp;java.util.stream.Collector&lt;S,&#8203;?,&#8203;java.util.concurrent.CompletableFuture&lt;java.util.List&lt;T&gt;&gt;&gt;&nbsp;toCombinedFuture()</pre>
<div class="block">Collector used at the end of a stream to convert a list of futures to a single future,
 combining the values into a list.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing a stream of futures to be combined into a single future.
 This converts <code>List&lt;CompletableFuture&lt;T&gt;&gt;</code> to <code>CompletableFuture&lt;List&lt;T&gt;&gt;</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>S</code> - the type of the input futures</dd>
<dd><code>T</code> - the type of the values</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a collector that combines the input futures as a list</dd>
</dl>
</li>
</ul>
<a id="combineFuturesAsMap(java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineFuturesAsMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;K,&#8203;V,&#8203;F extends java.util.concurrent.CompletableFuture&lt;? extends V&gt;&gt;&nbsp;java.util.concurrent.CompletableFuture&lt;java.util.Map&lt;K,&#8203;V&gt;&gt;&nbsp;combineFuturesAsMap&#8203;(java.util.Map&lt;? extends K,&#8203;? extends F&gt;&nbsp;futures)</pre>
<div class="block">Converts a map of futures to a single future.
 <p>
 This is similar to <a href="#combineFuturesAsList(java.util.List)"><code>combineFuturesAsList(List)</code></a> but for maps.
 Effectively, this converts <code>Map&lt;K, CompletableFuture&lt;V&gt;&gt;</code> to <code>CompletableFuture&lt;Map&lt;K, V&gt;&gt;</code>.
 <p>
 If any input future completes exceptionally, the result will also complete exceptionally.
 The results must be non-null.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - the type of the keys in the map</dd>
<dd><code>V</code> - the type of the values in the map</dd>
<dd><code>F</code> - the type of the futures, must not be Void</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - the futures to convert, may be empty</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a future that combines the input futures as a map</dd>
</dl>
</li>
</ul>
<a id="toCombinedFutureMap()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toCombinedFutureMap</h4>
<pre class="methodSignature">public static&nbsp;&lt;K,&#8203;V,&#8203;F extends java.util.concurrent.CompletableFuture&lt;? extends V&gt;&gt;&nbsp;java.util.stream.Collector&lt;java.util.Map.Entry&lt;? extends K,&#8203;? extends F&gt;,&#8203;?,&#8203;java.util.concurrent.CompletableFuture&lt;java.util.Map&lt;K,&#8203;V&gt;&gt;&gt;&nbsp;toCombinedFutureMap()</pre>
<div class="block">Collector used at the end of a stream to convert a map of futures to a single future,
 combining the values into a map.
 <p>
 A collector is used to gather data at the end of a stream operation.
 This method returns a collector allowing a stream of futures to be combined into a single future.
 This converts <code>Map&lt;K, CompletableFuture&lt;V&gt;&gt;</code> to <code>CompletableFuture&lt;Map&lt;K, V&gt;&gt;</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>K</code> - the type of the keys in the map</dd>
<dd><code>V</code> - the type of the values in the map</dd>
<dd><code>F</code> - the type of the input futures</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a collector that combines the input futures as a map</dd>
</dl>
</li>
</ul>
<a id="poll(java.util.concurrent.ScheduledExecutorService,java.time.Duration,java.time.Duration,java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>poll</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.concurrent.CompletableFuture&lt;T&gt;&nbsp;poll&#8203;(java.util.concurrent.ScheduledExecutorService&nbsp;executorService,
                                                                 java.time.Duration&nbsp;initialDelay,
                                                                 java.time.Duration&nbsp;frequency,
                                                                 java.util.function.Supplier&lt;T&gt;&nbsp;pollingTask)</pre>
<div class="block">Polls on a regular frequency until a result is found.
 <p>
 Polling is performed via the specified supplier, which must return null until the result is available.
 If the supplier throws an exception, polling will stop and the future will complete exceptionally.
 <p>
 If the future is cancelled, the polling will also be cancelled.
 It is advisable to consider using a timeout when querying the future.
 <p>
 In most cases, there needs to be an initial request, which might return an identifier to query.
 This pattern may be useful for that case:
 <pre>
  return CompletableFuture.supplyAsync(initPollingReturningId(), executorService)
      .thenCompose(id -&gt; poll(executorService, delay, freq, performPolling(id)));
  });
 </pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executorService</code> - the executor service to use for polling</dd>
<dd><code>initialDelay</code> - the initial delay before starting to poll</dd>
<dd><code>frequency</code> - the frequency to poll at</dd>
<dd><code>pollingTask</code> - the task used to poll, returning null when not yet complete</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the future representing the asynchronous operation</dd>
</dl>
</li>
</ul>
<a id="namedThreadFactory()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>namedThreadFactory</h4>
<pre class="methodSignature">public static&nbsp;com.google.common.util.concurrent.ThreadFactoryBuilder&nbsp;namedThreadFactory()</pre>
<div class="block">Creates a ThreadFactoryBuilder which names new threads with the name of the calling class plus a unique integer.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the thread factory builder</dd>
</dl>
</li>
</ul>
<a id="namedThreadFactory(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>namedThreadFactory</h4>
<pre class="methodSignature">public static&nbsp;com.google.common.util.concurrent.ThreadFactoryBuilder&nbsp;namedThreadFactory&#8203;(java.lang.String&nbsp;threadNamePrefix)</pre>
<div class="block">Creates a ThreadFactoryBuilder which names new threads with the given name prefix plus a unique integer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>threadNamePrefix</code> - the name which new thread names should be prefixed by</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the thread factory builder</dd>
</dl>
</li>
</ul>
<a id="callerClass(int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>callerClass</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Class&lt;?&gt;&nbsp;callerClass&#8203;(int&nbsp;callStackDepth)</pre>
<div class="block">Finds the caller class.
 <p>
 This takes an argument which is the number of stack levels to look back.
 This will be 2 to return the caller of this method, 3 to return the caller of the caller, and so on.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callStackDepth</code> - the depth of the stack to look back</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the caller class</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
